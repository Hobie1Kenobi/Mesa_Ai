{
  "language": "Solidity",
  "sources": {
    "RightsVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title RightsVault\n * @dev Core contract for storing and managing rights data with privacy features\n */\ncontract RightsVault {\n    address public owner;\n    bool private locked;\n\n    // Struct to store rights data\n    struct RightsData {\n        bytes32 encryptedData;      // Encrypted rights data\n        bytes32 dataHash;           // Hash of the original data\n        address rightsOwner;        // Address of the rights owner\n        uint256 timestamp;          // Timestamp of registration\n        bool isActive;              // Whether the rights are active\n    }\n\n    // Mapping from rights ID to RightsData\n    mapping(bytes32 => RightsData) public rightsRegistry;\n    \n    // Mapping from rights owner to their rights IDs\n    mapping(address => bytes32[]) public ownerRights;\n    \n    // Events\n    event RightsRegistered(bytes32 indexed rightsId, address indexed owner, uint256 timestamp);\n    event RightsUpdated(bytes32 indexed rightsId, address indexed owner);\n    event RightsDeactivated(bytes32 indexed rightsId);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        locked = false;\n    }\n\n    /**\n     * @dev Register new rights data\n     * @param rightsId Unique identifier for the rights\n     * @param encryptedData Encrypted rights data\n     * @param dataHash Hash of the original data\n     */\n    function registerRights(\n        bytes32 rightsId,\n        bytes32 encryptedData,\n        bytes32 dataHash\n    ) public virtual nonReentrant {\n        require(rightsRegistry[rightsId].timestamp == 0, \"Rights already registered\");\n        \n        rightsRegistry[rightsId] = RightsData({\n            encryptedData: encryptedData,\n            dataHash: dataHash,\n            rightsOwner: msg.sender,\n            timestamp: block.timestamp,\n            isActive: true\n        });\n        \n        ownerRights[msg.sender].push(rightsId);\n        \n        emit RightsRegistered(rightsId, msg.sender, block.timestamp);\n    }\n\n    /**\n     * @dev Update existing rights data\n     * @param rightsId Rights identifier to update\n     * @param encryptedData New encrypted rights data\n     * @param dataHash New hash of the original data\n     */\n    function updateRights(\n        bytes32 rightsId,\n        bytes32 encryptedData,\n        bytes32 dataHash\n    ) external nonReentrant {\n        require(rightsRegistry[rightsId].rightsOwner == msg.sender, \"Not rights owner\");\n        require(rightsRegistry[rightsId].isActive, \"Rights not active\");\n        \n        rightsRegistry[rightsId].encryptedData = encryptedData;\n        rightsRegistry[rightsId].dataHash = dataHash;\n        \n        emit RightsUpdated(rightsId, msg.sender);\n    }\n\n    /**\n     * @dev Deactivate rights\n     * @param rightsId Rights identifier to deactivate\n     */\n    function deactivateRights(bytes32 rightsId) external nonReentrant {\n        require(rightsRegistry[rightsId].rightsOwner == msg.sender, \"Not rights owner\");\n        require(rightsRegistry[rightsId].isActive, \"Rights already inactive\");\n        \n        rightsRegistry[rightsId].isActive = false;\n        \n        emit RightsDeactivated(rightsId);\n    }\n\n    /**\n     * @dev Get rights data\n     * @param rightsId Rights identifier\n     * @return RightsData struct containing the rights information\n     */\n    function getRightsData(bytes32 rightsId) external view returns (RightsData memory) {\n        return rightsRegistry[rightsId];\n    }\n\n    /**\n     * @dev Get all rights IDs for an owner\n     * @param _owner Address of the rights owner\n     * @return Array of rights IDs\n     */\n    function getOwnerRights(address _owner) public view virtual returns (bytes32[] memory) {\n        return ownerRights[_owner];\n    }\n}\n"
    },
    "EnhancedVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./RightsVault.sol\";\n\n/**\n * @title EnhancedVerification\n * @dev Enhanced verification system for rights management\n */\ncontract EnhancedVerification {\n    RightsVault public rightsVault;\n    address public owner;\n    bool private locked;\n\n    // Verification types\n    enum VerificationType { Identity, Ownership, Usage, License }\n\n    // Struct for verification data\n    struct Verification {\n        bytes32 rightsId;\n        VerificationType vType;\n        address verifier;\n        uint256 timestamp;\n        bool isValid;\n        string evidence;\n    }\n\n    // Struct for multi-signature verification\n    struct MultiSigVerification {\n        bytes32 rightsId;\n        address[] verifiers;\n        uint256 requiredSignatures;\n        mapping(address => bool) hasSigned;\n        uint256 signatureCount;\n        bool isComplete;\n    }\n\n    // Mapping from verification ID to Verification\n    mapping(bytes32 => Verification) public verifications;\n    \n    // Mapping from rights ID to array of verification IDs\n    mapping(bytes32 => bytes32[]) public rightsVerifications;\n    \n    // Mapping from multi-sig ID to MultiSigVerification\n    mapping(bytes32 => MultiSigVerification) public multiSigVerifications;\n    \n    // Events\n    event VerificationAdded(\n        bytes32 indexed verificationId,\n        bytes32 indexed rightsId,\n        VerificationType vType,\n        address indexed verifier\n    );\n    event VerificationInvalidated(bytes32 indexed verificationId);\n    event MultiSigVerificationCreated(\n        bytes32 indexed multiSigId,\n        bytes32 indexed rightsId,\n        uint256 requiredSignatures\n    );\n    event MultiSigVerificationSigned(\n        bytes32 indexed multiSigId,\n        address indexed signer\n    );\n    event MultiSigVerificationCompleted(bytes32 indexed multiSigId);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    constructor(address _rightsVault) {\n        owner = msg.sender;\n        rightsVault = RightsVault(_rightsVault);\n        locked = false;\n    }\n\n    /**\n     * @dev Add a new verification\n     * @param rightsId Rights identifier\n     * @param vType Type of verification\n     * @param evidence Verification evidence\n     * @return verificationId Unique identifier for the verification\n     */\n    function addVerification(\n        bytes32 rightsId,\n        VerificationType vType,\n        string calldata evidence\n    ) external nonReentrant returns (bytes32) {\n        bytes32 verificationId = keccak256(\n            abi.encodePacked(\n                rightsId,\n                vType,\n                msg.sender,\n                block.timestamp,\n                evidence\n            )\n        );\n\n        verifications[verificationId] = Verification({\n            rightsId: rightsId,\n            vType: vType,\n            verifier: msg.sender,\n            timestamp: block.timestamp,\n            isValid: true,\n            evidence: evidence\n        });\n\n        rightsVerifications[rightsId].push(verificationId);\n\n        emit VerificationAdded(verificationId, rightsId, vType, msg.sender);\n        return verificationId;\n    }\n\n    /**\n     * @dev Create a new multi-signature verification\n     * @param rightsId Rights identifier\n     * @param verifiers Array of verifier addresses\n     * @param requiredSignatures Number of required signatures\n     * @return multiSigId Unique identifier for the multi-sig verification\n     */\n    function createMultiSigVerification(\n        bytes32 rightsId,\n        address[] calldata verifiers,\n        uint256 requiredSignatures\n    ) external nonReentrant returns (bytes32) {\n        require(requiredSignatures > 0 && requiredSignatures <= verifiers.length, \"Invalid required signatures\");\n        \n        bytes32 multiSigId = keccak256(\n            abi.encodePacked(\n                rightsId,\n                verifiers,\n                requiredSignatures,\n                block.timestamp\n            )\n        );\n\n        MultiSigVerification storage multiSig = multiSigVerifications[multiSigId];\n        multiSig.rightsId = rightsId;\n        multiSig.verifiers = verifiers;\n        multiSig.requiredSignatures = requiredSignatures;\n        multiSig.signatureCount = 0;\n        multiSig.isComplete = false;\n\n        emit MultiSigVerificationCreated(multiSigId, rightsId, requiredSignatures);\n        return multiSigId;\n    }\n\n    /**\n     * @dev Sign a multi-signature verification\n     * @param multiSigId Multi-signature verification identifier\n     */\n    function signMultiSigVerification(bytes32 multiSigId) external nonReentrant {\n        MultiSigVerification storage multiSig = multiSigVerifications[multiSigId];\n        require(!multiSig.isComplete, \"Verification already complete\");\n        require(!multiSig.hasSigned[msg.sender], \"Already signed\");\n        \n        bool isVerifier = false;\n        for (uint i = 0; i < multiSig.verifiers.length; i++) {\n            if (multiSig.verifiers[i] == msg.sender) {\n                isVerifier = true;\n                break;\n            }\n        }\n        require(isVerifier, \"Not a verifier\");\n\n        multiSig.hasSigned[msg.sender] = true;\n        multiSig.signatureCount++;\n\n        emit MultiSigVerificationSigned(multiSigId, msg.sender);\n\n        if (multiSig.signatureCount >= multiSig.requiredSignatures) {\n            multiSig.isComplete = true;\n            emit MultiSigVerificationCompleted(multiSigId);\n        }\n    }\n\n    /**\n     * @dev Invalidate a verification\n     * @param verificationId Verification identifier\n     */\n    function invalidateVerification(bytes32 verificationId) external nonReentrant {\n        require(verifications[verificationId].verifier == msg.sender, \"Not verifier\");\n        require(verifications[verificationId].isValid, \"Already invalid\");\n        \n        verifications[verificationId].isValid = false;\n        \n        emit VerificationInvalidated(verificationId);\n    }\n\n    /**\n     * @dev Get verification data\n     * @param verificationId Verification identifier\n     * @return Verification struct containing the verification information\n     */\n    function getVerification(bytes32 verificationId) external view returns (Verification memory) {\n        return verifications[verificationId];\n    }\n\n    /**\n     * @dev Get all verifications for specific rights\n     * @param rightsId Rights identifier\n     * @return Array of verification IDs\n     */\n    function getRightsVerifications(bytes32 rightsId) external view returns (bytes32[] memory) {\n        return rightsVerifications[rightsId];\n    }\n\n    /**\n     * @dev Get multi-signature verification data\n     * @param multiSigId Multi-signature verification identifier\n     * @return rightsId Rights identifier\n     * @return verifiers Array of verifier addresses\n     * @return requiredSignatures Number of required signatures\n     * @return signatureCount Current number of signatures\n     * @return isComplete Whether the verification is complete\n     */\n    function getMultiSigVerificationData(bytes32 multiSigId) external view returns (\n        bytes32 rightsId,\n        address[] memory verifiers,\n        uint256 requiredSignatures,\n        uint256 signatureCount,\n        bool isComplete\n    ) {\n        MultiSigVerification storage multiSig = multiSigVerifications[multiSigId];\n        return (\n            multiSig.rightsId,\n            multiSig.verifiers,\n            multiSig.requiredSignatures,\n            multiSig.signatureCount,\n            multiSig.isComplete\n        );\n    }\n\n    /**\n     * @dev Get verifiers for a multi-signature verification\n     * @param multiSigId Multi-signature verification identifier\n     * @return Array of verifier addresses\n     */\n    function getMultiSigVerifiers(bytes32 multiSigId) external view returns (address[] memory) {\n        return multiSigVerifications[multiSigId].verifiers;\n    }\n\n     /**\n     * @dev Checks if a signer has signed a multi-signature verification\n     * @param multiSigId Multi-signature verification identifier\n     * @param signer Address of the signer to check\n     * @return bool indicating if the signer has signed\n     */\n    function hasSigned(bytes32 multiSigId, address signer) external view returns (bool) {\n        return multiSigVerifications[multiSigId].hasSigned[signer];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    },
    "compilationTarget": {
      "EnhancedVerification.sol": "EnhancedVerification"
    }
  }
} 